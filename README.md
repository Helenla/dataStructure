# dataStructure
不定期更新--


以js为表达数据结构相关知识


javascript一切皆对象

质数：除了1和本身外，不再有其他因数


数组：增删复杂，改查方便（数组的增删需要变动后面的数）
    特点：数组的长度是固定的，当超过时，添加新的数据就很困难
    数组的部分基本操作：
        pop()：尾部删除元素，
        shift()：头部删除元素，
        unshift()：头部添加元素，
        join()：将数组中的元素拼接成字符串返回
        slice()：截取数组中的子数组并返回为纯数组
        splice()：删除，插入，替换 返回的是删除的子数组
        reverse()：反转数组
        split()：将字符串分割成数组，返回分割后的数组，原数组不变


栈：先进后出
    佩兹糖果问题：建两个栈，一个存要删除的，一个存余下的


队：先进先出
    优先队列：给队列一个code值，依据code值判断是否先出
    双向队列：前后都可进行增删


链表：增删方便，改查复杂 （查找不是连贯的，是一步一步查找，花费很多时间）
    单向链表：每个节点都有个指向，指往下一个节点，最后指向null
    双向链表：每个节点都有前后指向，头节点前指向为null，尾结点后指向为null。
    循环链表：节点为单向，但尾结点指向头节点 以此实现循环


字典（dictionary）：以键-值对的形式存储数据的数据结构，js的Object类就是字典的形式设计的。（基础是Array类）
    for-in 循环会枚举其原型链上的属性,  
    当键的属性为字符串时  length属性失效
    el:pook['daved']=1   pook.length=0


散列表（哈希表 HashTable）：散列数据，类似于字典表的键-值形式（每个散列都会有很多空位置）
    特点：插入、删除、取数据都非常快，但是消耗太多内存
    hashTable：哈希表，以数组new Array()的形式表现，一般给一个存储的量（质数 例如：137）
    散列值（哈希值）：存储时把数据用charCodeAt()方法转化为ASCII码求和，然后除于数组的长度求余（除留余数法）
    哈希值碰撞：哈希值相同，显示的数据就不会全部显示
    解决 哈希值碰撞：
        霍纳算法：求和时每次都乘一个质数（例如：31）
            total += H * total + string.charCodeAt(i);
        开链法：散数列表的底层数组中，行开辟一个数据结构，比如另一个数组，这样可以储存多个键
        线性探测法：碰撞时，寻找他的下一个地址是否有键，没有就存入，有就继续想下一个寻找


集合：有一组无序但彼此之间又有一定关系的成员构成的，每个成员在集合中只能出现一次（indexOf方法很关键）


二叉树：进行查找非常快，为二叉树添加或删除元素也非常快
    前序：根节点->左节点->右节点
    中序：左节点->根节点->右节点
    后序：左节点->右节点->根节点
    规律：小于根节点的键放在左节点（可以利用此查找最小键），大于根节点的键放在右节点（查找最大键）


图：无序图，有向图


<br>
------------------------------------------------------------------------------------------------------

排序算法

以下3个排序的复杂度相似，执行效率也差不多。
选择排序和插入排序要比冒泡排序快，插入排序是这三种算法中最快的。

1.冒泡算法：循环数组的长度，依次两两对比，大的向后移动。

2.选择排序：从第一个元素开始，开始循环，外层一个循环为了每个元素都可以对比，里层循环是外层元素后面的元素依次与外层元素对比，比其大就互换位置。

3,插入排序：
[5]   6   3   1   8   7   2   4
  ↑   │
  └───┘
[5, 6]   3   1   8   7   2   4
↑        │
└────────┘
[3, 5, 6]  1   8   7   2   4
↑          │
└──────────┘
[1, 3, 5, 6]  8   7   2   4
           ↑  │
           └──┘
[1, 3, 5, 6, 8]  7   2   4
            ↑    │
            └────┘
[1, 3, 5, 6, 7, 8]  2   4
   ↑                │
   └────────────────┘
[1, 2, 3, 5, 6, 7, 8]  4
         ↑             │
         └─────────────┘
 
[1, 2, 3, 4, 5, 6, 7, 8]


<br>
------------------------------------------------------------------------------------------------------


高级排序算法

1.希尔排序：通过定义一个间隔序列来表示在排序过程中进行比较的元素之间有多远的间隔，然后比较，比较结束之后再取n/2的间隔数继续比较直到间隔为1
2.归并算法：把数据分为左右块，从分为单个元素开始依次俩俩对比，然后合并大小
3.快速排序：取一个中间值，然后比较是否比这个值大，然后再分开，比其大的一部分，小的一部分，每个部分继续取中间值比较，依次进行。